

# **Understanding Data Types in JavaScript**

In JavaScript, every piece of data, every value, belongs to a specific **data type**. This classification helps the language understand how to interpret and interact with that data. For instance, a value like 10 is treated differently than a value like "hello".

JavaScript is a **dynamically typed** language. This means that while values have types, variables themselves are not "bound" to a particular type. A variable can hold a number, then later hold a string, and JavaScript will adapt without error.

JavaScript

let message = "hello"; // 'message' holds a string

message = 123456;    // Now 'message' holds a number - no error!

This dynamic nature offers flexibility but also requires careful attention to the types of data you're working with at any given moment.

There are **eight basic data types** in JavaScript. We'll explore each of them in detail.


---


## **1. Number**

The number type is used to represent both **integers** (whole numbers) and **floating-point numbers** (numbers with decimal points).

JavaScript

let n = 123;    // An integer

n = 12.345; // A floating-point number

Numbers support all standard mathematical operations:



* + (addition)
* - (subtraction)
* * (multiplication)
* / (division)
* % (modulo - remainder of division)
* ** (exponentiation)


### **Special Numeric Values**

Beyond regular numbers, the number data type also includes three "special numeric values":



* Infinity (positive infinity)
* -Infinity (negative infinity)
* NaN (Not a Number)


#### **Infinity**

Infinity represents the mathematical concept of infinity (∞). It's a value greater than any other number.

You can obtain Infinity as a result of division by zero:

JavaScript

alert( 1 / 0 ); // Output: Infinity

Or, you can reference it directly:

JavaScript

alert( Infinity ); // Output: Infinity


#### **NaN**

NaN represents a **computational error**. It arises from an incorrect or undefined mathematical operation.

JavaScript

alert( "not a number" / 2 ); // Output: NaN (because you can't divide a string by a number)

**NaN is "sticky"**: If NaN is involved in any further mathematical operation (except for NaN ** 0, which is 1), the result will also be NaN.

JavaScript

alert( NaN + 1 );          // Output: NaN

alert( 3 * NaN );          // Output: NaN

alert( "not a number" / 2 - 1 ); // Output: NaN

This "stickiness" helps you trace errors; if you get NaN as a result, it often indicates an invalid operation happened earlier in the calculation.


### **JavaScript Maths are "Safe"**

A key characteristic of JavaScript's number operations is their "safety." You can perform almost any mathematical operation without the script crashing. Instead of a fatal error, you'll typically get Infinity, -Infinity, or NaN as a result. This prevents your entire application from "dying" due to a simple math mistake.



* **Note:** While Infinity, -Infinity, and NaN formally belong to the "number" type, they aren't numbers in the traditional sense.

We'll delve deeper into working with numbers in a dedicated chapter.


---


## **2. BigInt**

The standard number type in JavaScript uses a 64-bit floating-point format, which means it has a limit on the size of integers it can safely represent. Specifically, it can safely represent integers only up to pm(253−1) (which is pm9,007,199,254,740,991).

Beyond this "safe integer" range, precision errors can occur because not all digits fit into the fixed 64-bit storage. For example:

JavaScript

console.log(9007199254740991 + 1); // Output: 9007199254740992

console.log(9007199254740991 + 2); // Output: 9007199254740992 (Notice: adding 1 or 2 gives the same result!)

This means that odd integers larger than (253−1) cannot be stored precisely using the number type.

For most everyday tasks, the pm(253−1) range is sufficient. However, for specialized applications like cryptography, working with very large IDs, or microsecond-precision timestamps, we need to handle arbitrarily large integers without losing precision.

The BigInt type was recently introduced to JavaScript (part of the ECMAScript 2020 standard) to address this need. It represents integers of arbitrary length.

You create a BigInt value by appending n to the end of an integer literal:

JavaScript

// The 'n' at the end signifies it's a BigInt

const bigInt = 1234567890123456789012345678901234567890n;

BigInt numbers are not frequently needed in typical web development, so they are covered in a separate, more advanced chapter. Use BigInt when you truly require precision for integers larger than Number.MAX_SAFE_INTEGER.


---


## **3. String**

A string in JavaScript is a sequence of characters used to represent text. Strings must always be surrounded by quotes. JavaScript offers three types of quotes:



1. **Double quotes:** "Hello"
2. **Single quotes:** 'Single quotes are ok too'
3. **Backticks (template literals):** `can embed another ${str}`


### **Simple Quotes (" and ')**

Double and single quotes are "simple" quotes. There is practically no functional difference between them in JavaScript. You can choose whichever you prefer, but consistency within your codebase is a good practice.


### **Backticks (Template Literals)**

Backticks provide "extended functionality" and are often called **template literals**. Their main advantage is that they allow you to **embed variables and expressions directly into a string**. You do this by wrapping them in ${...}.

Let's see an example:

JavaScript

let name = "John";

// Embed a variable

alert( `Hello, ${name}!` ); // Output: Hello, John!

You can also embed more complex expressions:

JavaScript

// Embed an expression

alert( `The result is ${1 + 2}` ); // Output: The result is 3

The expression inside ${...} is evaluated, and its result is converted into a string and becomes part of the larger template literal. You can place anything inside: a variable, an arithmetic expression, or even a function call.

**Important:** This embedding functionality (${...}) works **only** with backticks. Simple quotes will not interpret the embedded expression; they will treat it as plain text:

JavaScript

alert( "The result is ${1 + 2}" ); // Output: The result is ${1 + 2} (double quotes do nothing)

We'll cover strings and their methods more thoroughly in a dedicated chapter.


### **No char Type**

Unlike some other languages (like C or Java, which have a char type for a single character), JavaScript does not have a separate "character" type. There's only one type for text: string. A string can be empty, contain a single character, or many characters.


---


## **4. Boolean (Logical Type)**

The boolean type is very simple, having only two possible values: true and false.

This type is fundamental for storing yes/no, on/off, or true/false conditions.



* true typically means "yes" or "correct."
* false typically means "no" or "incorrect."

Here's how you might use boolean variables:

JavaScript

let nameFieldChecked = true;  // Yes, the name field is checked

let ageFieldChecked = false;  // No, the age field is not checked

Boolean values also commonly result from comparisons:

JavaScript

let isGreater = 4 > 1; // Is 4 greater than 1? Yes!

alert( isGreater );      // Output: true

Booleans are extensively used in conditional statements (like if...else) and logical operations, which we will explore in detail later.


---


## **5. The "null" Value**

The special null value forms a distinct type of its own, containing only the null value itself.

JavaScript

let age = null;

In JavaScript, null is *not* like a "reference to a non-existing object" or a "null pointer" as it might be in some other programming languages.

Instead, null is simply a special value that represents:



* "nothing"
* "empty"
* "value unknown"

The example let age = null; effectively states that the age is currently unknown or intentionally empty.


---


## **6. The "undefined" Value**

The special undefined value also stands as a separate type, containing only the undefined value.

The meaning of undefined is precisely "value is not assigned."

If you declare a variable but do not assign it an initial value, JavaScript automatically assigns it undefined:

JavaScript

let age; // Variable declared, but no value assigned

alert(age); // Output: undefined

While it's technically possible to explicitly assign undefined to a variable, it's generally **not recommended**:

JavaScript

let age = 100;

// ... later ...

age = undefined; // Don't typically do this

alert(age);      // Output: undefined

The convention is to use null when you want to explicitly state that a variable is "empty" or "unknown." undefined is typically reserved as the default initial value for things that haven't been assigned yet.


---


## **7. Object**

The object type is fundamentally different from the primitive types we've discussed so far.

All other types (number, bigint, string, boolean, null, undefined, symbol) are called "**primitive**" data types. Their values can contain only a single piece of data (e.g., a single number, a single string).

In contrast, **objects are used to store collections of data and more complex entities.** They allow you to group related information together. For example, you might have an object representing a user, containing their name, age, and email.

JavaScript

// A simple object representing a user

let user = {

  name: "Alice",

  age: 30

};

Objects are a cornerstone of JavaScript programming and are incredibly important. We will dedicate a separate, in-depth chapter to objects after we've gained a solid understanding of the primitive types.


---


## **8. Symbol**

The symbol type is relatively new, introduced in ECMAScript 2015 (ES6). Its primary purpose is to create **unique identifiers** for objects.

Symbols guarantee uniqueness. Even if you create two symbols with the same description, they are distinct values.

JavaScript

let id1 = Symbol("id");

let id2 = Symbol("id");

alert(id1 == id2); // Output: false (they are unique)

We briefly mention symbol here for completeness, but the details and practical applications of symbols are best understood once you have a firm grasp of objects, so we'll cover them later.


---


## **The typeof Operator**

The typeof operator is a handy tool that returns a string indicating the **type** of its operand (the value you're inspecting). It's incredibly useful for debugging, validating inputs, or when you need to process values differently based on their type.

A call to typeof x returns a string with the type name:

JavaScript

typeof undefined   // "undefined"

typeof 0           // "number"

typeof 10n         // "bigint"

typeof true        // "boolean"

typeof "foo"       // "string"

typeof Symbol("id")// "symbol"

typeof Math        // "object"  (1)

typeof null        // "object"  (2) - This is a known error!

typeof alert       // "function" (3) - Functions are objects, but typeof gives "function"

Let's clarify the last three results:



1. **Math is a built-in object** in JavaScript that provides mathematical functions (e.g., Math.random(), Math.floor()). It serves as a good example of an object.
2. **typeof null returns "object"**. This is an officially recognized **error** in the JavaScript language, inherited from its very early days and kept for backward compatibility. It's crucial to remember that null is *not* an object; it's a special primitive value with its own type.
3. **typeof alert returns "function"**. While alert is a function (which, in JavaScript, are technically a special kind of object), the typeof operator specifically returns "function" for functions. This is a historical quirk that can be convenient in practice for identifying functions.


### **The typeof(x) Syntax**

You might occasionally see typeof used with parentheses, like typeof(x). This is equivalent to typeof x.

To be clear: typeof is an **operator**, not a function. The parentheses here are not part of typeof itself; they are the same kind of parentheses used for mathematical grouping, like (2 + 2). In this context, they simply enclose the single argument x. Syntactically, they allow you to omit a space between typeof and its argument.

While typeof(x) is syntactically valid, typeof x is much more common and generally preferred.


---


## **Summary of Data Types**

As of today, July 26, 2025, there are 8 basic data types in JavaScript:


### **Seven Primitive Data Types:**



1. **number**: For both integer and floating-point numbers. Integers are limited to pm(253−1) for safe precision.
2. **bigint**: For integer numbers of arbitrary length, beyond the safe range of number.
3. **string**: For sequences of characters (text). A string can have zero or more characters; there's no separate single-character type.
4. **boolean**: For logical values: true or false.
5. **null**: A standalone type with a single value null, representing "nothing," "empty," or "unknown value."
6. **undefined**: A standalone type with a single value undefined, representing "value not assigned."
7. **symbol**: Used to create unique identifiers.


### **One Non-Primitive Data Type:**



1. **object**: For more complex data structures, used to store collections of data.

The typeof operator allows us to determine the type of a value stored in a variable:



* Usually used as typeof x.
* typeof(x) is also possible but less common.
* Returns a string with the name of the type (e.g., "string", "number").
* **Important exception**: For null, typeof returns "object", which is a known error in the language.

In upcoming chapters, we will focus on mastering the primitive data types before moving on to the more complex object type.


---


## **Tasks**


### **String Quotes**

What is the output of the script?

JavaScript

let name = "Ilya";

alert( `hello ${1}` );    // ?

alert( `hello ${"name"}` ); // ?

alert( `hello ${name}` ); // ?
