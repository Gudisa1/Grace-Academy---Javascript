

# **Basic Operators and Mathematics in JavaScript**

In programming, **operators** are special symbols or keywords that tell the JavaScript engine to perform some operation on values (called **operands**). Many operators, like addition + or multiplication *, are familiar from school. However, JavaScript also has unique aspects to its operators that are crucial to understand.


---


## **Terms: "Unary", "Binary", "Operand"**

Before diving into the operators, let's clarify some common terminology:



* **Operand**: An operand is the value or variable that an operator acts upon.
    * In the expression 5 * 2, 5 is the left operand and 2 is the right operand.
    * Sometimes, operands are also referred to as "arguments."
* **Unary Operator**: An operator is **unary** if it operates on a single operand.
    * Example: The unary negation operator - reverses the sign of a number.
* JavaScript

let x = 1;

x = -x;    // Unary negation applied to x

alert(x);  // Output: -1



* 
* 
* **Binary Operator**: An operator is **binary** if it operates on two operands.
    * Example: The subtraction operator - is a binary operator that subtracts one value from another.
* JavaScript

let x = 1, y = 3;

alert(y - x); // Binary minus subtracts 1 from 3

alert(y - x); // Output: 2



* 
* Notice that the minus symbol (-) can act as both a unary and a binary operator, depending on how many operands it has. They are formally distinct operators that share the same symbol.


---


## **Mathematical Operators**

JavaScript supports all the standard arithmetic operations you'd expect:



* **Addition**: +
* **Subtraction**: -
* **Multiplication**: *
* **Division**: /
* **Remainder (Modulo)**: %
* **Exponentiation**: **

The first four (+, -, *, /) are straightforward. Let's look closer at % and **.


### **Remainder Operator (%)**

The remainder operator % (often called the modulo operator) calculates the **remainder** of an integer division. It has nothing to do with percentages.



* a % b gives you the remainder when a is divided by b.

JavaScript

alert(5 % 2); // Output: 1 (5 divided by 2 is 2 with a remainder of 1)

alert(8 % 3); // Output: 2 (8 divided by 3 is 2 with a remainder of 2)

alert(8 % 4); // Output: 0 (8 divided by 4 is 2 with a remainder of 0)


### **Exponentiation Operator (**)**

The exponentiation operator a ** b raises a to the power of b. In mathematical notation, this is written as ab.

JavaScript

alert(2 ** 2); // Output: 4 (2 to the power of 2, or 2²)

alert(2 ** 3); // Output: 8 (2 to the power of 3, or 2³)

alert(2 ** 4); // Output: 16 (2 to the power of 4, or 2⁴)

The exponentiation operator also works with non-integer numbers, just like in mathematics. For example, a square root is equivalent to raising a number to the power of 1/2:

JavaScript

alert(4 ** (1/2)); // Output: 2 (square root of 4)

alert(8 ** (1/3)); // Output: 2 (cubic root of 8)


---


## **String Concatenation with Binary +**

This is a key JavaScript-specific behavior that often surprises newcomers. While the binary + operator usually sums numbers, if **any** of its operands is a string, it performs **string concatenation** (merging strings) instead. The other operand is also converted to a string.

JavaScript

let s = "my" + "string";

alert(s); // Output: mystring

This rule applies regardless of whether the string is the first or second operand:

JavaScript

alert('1' + 2); // Output: "12" (2 is converted to "2", then concatenated)

alert(2 + '1'); // Output: "21" (2 is converted to "2", then concatenated)


### **Order of Operations Matters:**

Consider this more complex example:

JavaScript

alert(2 + 2 + '1'); // Output: "41"

Here's how it's evaluated:



1. 2 + 2 is evaluated first (because + has left-to-right associativity when priorities are the same). This sums two numbers, resulting in 4.
2. Then, 4 + '1' is evaluated. Since '1' is a string, 4 is converted to "4", and then "4" and "1" are concatenated. Result: "41".

Now, compare that to this:

JavaScript

alert('1' + 2 + 2); // Output: "122"

Evaluation:



1. '1' + 2 is evaluated first. Since '1' is a string, 2 is converted to "2", and they are concatenated. Result: "12".
2. Then, '12' + 2 is evaluated. Again, since '12' is a string, 2 is converted to "2", and they are concatenated. Result: "122".

**Crucial Point:** The binary + is the *only* arithmetic operator that behaves this way with strings. Other arithmetic operators (-, *, /, %, **) *always* convert their operands to numbers before performing the operation.

JavaScript

alert(6 - '2');    // Output: 4 (converts '2' to the number 2)

alert('6' / '2');  // Output: 3 (converts '6' to 6 and '2' to 2)


---


## **Numeric Conversion with Unary +**

The + symbol also exists in a **unary** form (applied to a single value).



* When applied to a number, the unary + does nothing.
* When applied to a non-number, the unary + converts it into a number.

JavaScript

// No effect on numbers

let x = 1;

alert(+x); // Output: 1

let y = -2;

alert(+y); // Output: -2

// Converts non-numbers to numbers

alert(+true);  // Output: 1

alert(+"");    // Output: 0

alert(+"   123   "); // Output: 123

alert(+"123z"); // Output: NaN

The unary + effectively performs the same numeric conversion as the Number() function, but it's a shorter syntax.

This is extremely useful when you get values as strings (e.g., from an HTML form) and you need to perform mathematical calculations on them.

JavaScript

let apples = "2";

let oranges = "3";

// Without unary plus, binary plus concatenates strings:

alert(apples + oranges); // Output: "23"

// With unary plus, strings are converted to numbers first, then summed:

alert(+apples + +oranges); // Output: 5

// This is equivalent to:

// alert(Number(apples) + Number(oranges)); // Output: 5

From a mathematician's perspective, seeing multiple plus signs like +apples + +oranges might look odd. But from a programmer's perspective, it's clear: the unary + operators are applied first to convert apples and oranges into numbers, and *then* the binary + operator performs numeric addition.


---


## **Operator Precedence**

When an expression contains more than one operator, the order in which they are executed is determined by their **precedence**. Operators with higher precedence are evaluated before operators with lower precedence.



* You already know this from school arithmetic: multiplication and division are performed before addition and subtraction (e.g., 1 + 2 * 2 equals 5, not 6). Multiplication (*) has a higher precedence than addition (+).
* **Parentheses ()** can always override the default precedence. Use them to enforce a specific order of operations (e.g., (1 + 2) * 2 equals 6).

Every operator in JavaScript has a corresponding precedence number. A higher number means higher priority. If operators have the same precedence, they are typically evaluated from left to right (this is called **associativity**).

Here's an extract from the JavaScript operator precedence table (you don't need to memorize the numbers, but observe the relative priorities):


<table>
  <tr>
   <td>Precedence
   </td>
   <td>Name
   </td>
   <td>Sign
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>14</strong>
   </td>
   <td>unary plus
   </td>
   <td>+
   </td>
  </tr>
  <tr>
   <td><strong>14</strong>
   </td>
   <td>unary negation
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td><strong>13</strong>
   </td>
   <td>exponentiation
   </td>
   <td>**
   </td>
  </tr>
  <tr>
   <td><strong>12</strong>
   </td>
   <td>multiplication
   </td>
   <td>*
   </td>
  </tr>
  <tr>
   <td><strong>12</strong>
   </td>
   <td>division
   </td>
   <td>/
   </td>
  </tr>
  <tr>
   <td><strong>11</strong>
   </td>
   <td>addition
   </td>
   <td>+
   </td>
  </tr>
  <tr>
   <td><strong>11</strong>
   </td>
   <td>subtraction
   </td>
   <td>-
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>2</strong>
   </td>
   <td>assignment
   </td>
   <td>=
   </td>
  </tr>
  <tr>
   <td>...
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


As you can see, "unary plus" (precedence 14) has a higher priority than "addition" (binary plus, precedence 11). This is why +apples + +oranges works as expected: the unary pluses convert to numbers *before* the binary plus performs addition.


---


## **Assignment Operator (=)**

The assignment operator = is also an operator in JavaScript. It has a very low precedence (2). This means that in an expression like x = 2 * 2 + 1, the calculations on the right side (2 * 2 + 1) are performed first, and then the result is assigned to x.

JavaScript

let x = 2 * 2 + 1; // 2 * 2 evaluates to 4, then 4 + 1 evaluates to 5.

alert(x);          // Output: 5


### **Assignment Returns a Value**

All operators in JavaScript return a value. For + and -, this is obvious. For =, it's also true. The expression x = value not only assigns value to x but also **returns that value**.

This allows for interesting (though sometimes less readable) constructs:

JavaScript

let a = 1;

let b = 2;

// The assignment (a = b + 1) evaluates to 3,

// which is then used in the subtraction: 3 - 3 = 0

let c = 3 - (a = b + 1);

alert(a); // Output: 3 (because a was assigned b + 1, which is 3)

alert(c); // Output: 0 (because c = 3 - 3)

While understanding this behavior is important (you might encounter it in some codebases), it's generally advised **not to write code like this** as it can make it harder to read and debug.


### **Chaining Assignments**

Another feature is the ability to chain assignments:

JavaScript

let a, b, c;

a = b = c = 2 + 2; // All variables get the value 4

alert(a); // Output: 4

alert(b); // Output: 4

alert(c); // Output: 4

Chained assignments evaluate from **right to left**.



1. 2 + 2 is evaluated first, resulting in 4.
2. c = 4 is performed, and 4 is returned.
3. b = 4 (the returned value from c = 4) is performed, and 4 is returned.
4. a = 4 (the returned value from b = 4) is performed.

This results in all variables sharing the same value.

Again, for better readability, it's often preferable to split chained assignments into multiple lines, especially if you're quickly scanning the code:

JavaScript

c = 2 + 2;

b = c;

a = c;


---


## **Modify-in-Place Operators (Compound Assignment)**

It's very common to apply an operation to a variable and store the result back into the same variable.

For example, to increase n by 5:

JavaScript

let n = 2;

n = n + 5; // n is now 7

JavaScript provides **compound assignment operators** (also called "modify-in-place" operators) as a shorthand for this. These exist for all arithmetic and bitwise operators: +=, -=, *=, /=, %=, **=, etc.

JavaScript

let n = 2;

n += 5; // Same as n = n + 5; now n is 7

n *= 2; // Same as n = n * 2; now n is 14

alert(n); // Output: 14

These operators have the same low precedence as a normal assignment (=), meaning the right side of the expression is evaluated completely before the assignment happens.

JavaScript

let n = 2;

n *= 3 + 5; // First, (3 + 5) evaluates to 8. Then, n *= 8 (n = n * 8)

alert(n);   // Output: 16 (2 * 8)


---


## **Increment (++) and Decrement (--)**

Increasing or decreasing a number by one is such a common operation that JavaScript provides special shorthand operators for it:



* **Increment ++**: Increases a variable by 1.
* **Decrement --**: Decreases a variable by 1.

JavaScript

let counter = 2;

counter++;        // Same as counter = counter + 1;

alert(counter);   // Output: 3

let anotherCounter = 2;

anotherCounter--; // Same as anotherCounter = anotherCounter - 1;

alert(anotherCounter); // Output: 1

**Important Notes:**



* Increment/decrement operators **can only be applied to variables**. You cannot use them on a direct value, like 5++ (this would result in an error).
* These operators can be placed either **before** or **after** the variable.


### **Prefix vs. Postfix Forms**

The placement of ++ or -- relative to the variable determines its "form":



* **Postfix form**: When the operator comes *after* the variable (e.g., counter++).
* **Prefix form**: When the operator comes *before* the variable (e.g., ++counter).

Both forms increment/decrement the variable by one. The difference lies in the **value they return**:



* **Prefix form (++counter)**: Returns the **new value** of the variable (after incrementing/decrementing).
* **Postfix form (counter++)**: Returns the **old value** of the variable (before incrementing/decrementing).

Let's see this in action:


#### **Prefix Example:**

JavaScript

let counter = 1;

let a = ++counter; // (*)

alert(counter);    // Output: 2 (counter is incremented)

alert(a);          // Output: 2 (a gets the *new* value of counter)

In line (*):



1. counter is incremented to 2.
2. The *new* value of counter (2) is returned.
3. This returned value (2) is assigned to a.


#### **Postfix Example:**

JavaScript

let counter = 1;

let a = counter++; // (*)

alert(counter);    // Output: 2 (counter is incremented)

alert(a);          // Output: 1 (a gets the *old* value of counter)

In line (*):



1. The *old* value of counter (1) is returned first.
2. This returned value (1) is assigned to a.
3. Then, counter is incremented to 2.


#### **When the Result Isn't Used:**

If you're just incrementing/decrementing and don't need the returned value immediately, there's no difference between the forms:

JavaScript

let counter = 0;

counter++;   // counter becomes 1

++counter;   // counter becomes 2

alert(counter); // Output: 2


### **Increment/Decrement in Expressions**

++ and -- can be used directly within larger expressions. They have higher precedence than most other arithmetic operations (precedence 14).

JavaScript

let counter = 1;

alert(2 * ++counter); // Output: 4

// Evaluation:

// 1. ++counter increments counter to 2, and returns 2.

// 2. 2 * 2 is then calculated.

Compare that with the postfix form:

JavaScript

let counter = 1;

alert(2 * counter++); // Output: 2

// Evaluation:

// 1. counter++ returns the old value of counter (1).

// 2. 2 * 1 is then calculated.

// 3. After the whole expression, counter is then incremented to 2.

While syntactically valid, using ++/-- inside complex expressions can make the code less readable. It often leads to "one line, multiple actions," which can be hard to quickly understand. A common recommendation is to keep increments/decrements on their own line for clarity:

JavaScript

let counter = 1;

alert(2 * counter); // Use current value

counter++;          // Increment on a separate line


---


## **Bitwise Operators**

Bitwise operators treat their operands as 32-bit integers and perform operations directly on their binary representations (bits).

The list of bitwise operators:



* & (AND)
* | (OR)
* ^ (XOR)
* ~ (NOT)
* <&lt; (LEFT SHIFT)
* >> (RIGHT SHIFT)
* >>> (ZERO-FILL RIGHT SHIFT)

These operators are rarely used in typical web development, as they deal with numbers at a very low level. They are more common in specific areas like cryptography, graphics processing, or working directly with hardware. You can find more details in resources like the MDN Bitwise Operators chapter if a need arises.


---


## **Comma Operator (,)**

The comma operator , is one of JavaScript's more unusual and less commonly used operators. It allows you to evaluate several expressions, separated by commas, but it only returns the result of the **last** expression.

JavaScript

let a = (1 + 2, 3 + 4); // The parentheses are important here due to low precedence

alert(a);               // Output: 7 (the result of 3 + 4)

In this example:



1. 1 + 2 is evaluated (result 3), but this result is discarded.
2. 3 + 4 is evaluated (result 7).
3. The result 7 is returned by the comma operator and assigned to a.


### **Comma has Very Low Precedence**

The comma operator has an extremely low precedence (lower than assignment =). This is why parentheses were crucial in the example let a = (1 + 2, 3 + 4);.

Without the parentheses, a = 1 + 2, 3 + 4 would be parsed differently:



* First, 1 + 2 evaluates to 3.
* Then, a = 3 assigns 3 to a. The value 3 is returned by the assignment.
* Then, 3, 3 + 4 is evaluated. The 3 is discarded, 3 + 4 is 7. But since the assignment already happened, the 7 is simply evaluated and then discarded.
* So, a would be 3, and 7 would be ignored. It effectively becomes (a = 1 + 2), (3 + 4).


### **Why Use the Comma Operator?**

While unusual, the comma operator is sometimes used in complex constructs (especially in for loops) to put several actions on a single line.

JavaScript

// Example in a for loop: three operations in the initialization part

for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {

  // ... loop body ...

}

You might encounter this in some JavaScript frameworks. However, for everyday code, using the comma operator often decreases readability. It's generally best to avoid it unless there's a very clear benefit and your team agrees on its usage.


---


## **Tasks**


### **The Postfix and Prefix Forms**

What are the final values of all variables a, b, c, and d after the code below?

JavaScript

let a = 1, b = 1;

let c = ++a; // ?

let d = b++; // ?


### **Assignment Result**

What are the values of a and x after the code below?

JavaScript

let a = 2;

let x = 1 + (a *= 2);


### **Type Conversions**

What are the results of these expressions? Think carefully, write them down, and then compare with the actual output.

JavaScript

"" + 1 + 0

"" - 1 + 0

true + false

6 / "3"

"2" * "3"

4 + 5 + "px"

"$" + 4 + 5

"4" - 2

"4px" - 2

"  -9  " + 5

"  -9  " - 5

null + 1

undefined + 1

" \t \n" - 2


### **Fix the Addition**

Here's a code that asks the user for two numbers and shows their sum. It works incorrectly. For default prompt values (1 and 2), the output is "12".

Why? Fix it. The result should be 3.

JavaScript

let a = prompt("First number?", 1);

let b = prompt("Second number?", 2);

alert(a + b); // 12 (incorrect)
