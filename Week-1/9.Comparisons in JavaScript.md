


# **Comparisons in JavaScript**

Comparison operators are fundamental to controlling program flow and making decisions in your code. Like in mathematics, these operators allow you to compare two values. In JavaScript, they return a boolean result, indicating whether the comparison is true or false.


---


## **Basic Comparison Operators**

JavaScript uses familiar symbols for its comparison operators:



* **Greater than**: a > b
* **Less than**: a &lt; b
* **Greater than or equals**: a >= b
* **Less than or equals**: a &lt;= b
* **Equals (Loose Equality)**: a == b (Note the double equals sign == for comparison, distinct from the single equals sign = which is for assignment).
* **Not equals (Loose Inequality)**: a != b (The mathematical notation is ≠).


### **Boolean is the Result**

All comparison operators in JavaScript return a **boolean** value:



* true: Means the comparison is correct, "yes," or "the truth."
* false: Means the comparison is incorrect, "no," or "not the truth."

**Examples:**

JavaScript

alert(2 > 1);  // Output: true (2 is greater than 1)

alert(2 == 1); // Output: false (2 is not equal to 1)

alert(2 != 1); // Output: true (2 is not equal to 1)

The result of a comparison can be stored in a variable, just like any other value:

JavaScript

let result = 5 > 4; // The comparison 5 > 4 evaluates to true

alert(result);      // Output: true


---


## **String Comparison**

When comparing strings, JavaScript uses a "dictionary" or "lexicographical" order. This means strings are compared character-by-character from left to right.

**Examples:**

JavaScript

alert('Z' > 'A');    // Output: true (Because 'Z' comes after 'A' alphabetically)

alert('Glow' > 'Glee');  // Output: true (o comes after e)

alert('Bee' > 'Be');   // Output: true (Longer string is greater if prefixes are identical)


### **The String Comparison Algorithm:**

The algorithm JavaScript uses to compare two strings is straightforward:



1. Compare the **first character** of both strings.
    * If the first character of the first string is greater (or less) than the first character of the second string, then the first string is greater (or less). The comparison is complete.
2. If the first characters are the same, compare the **second characters** in the same way.
3. This process repeats, comparing characters position by position, until:
    * A difference is found (e.g., in 'Glow' vs 'Glee', 'o' is compared to 'e', and 'o' is greater, so 'Glow' is greater).
    * The end of either string is reached. If both strings end at the same length and all characters matched, they are equal. Otherwise, the longer string is considered greater (e.g., 'Bee' is greater than 'Be' because 'Bee' is longer and 'Be' matches the prefix).


### **Not a Real Dictionary (Unicode Order)**

It's important to note that this comparison is based on the characters' numerical positions in the **Unicode encoding table**, not a human-language dictionary. This has a few key implications:



* **Case matters**: A capital letter "A" is *not* equal to the lowercase "a". Furthermore, lowercase letters generally have larger Unicode indices than uppercase letters.
* JavaScript

alert('a' > 'Z'); // Output: true (lowercase 'a' comes after uppercase 'Z' in Unicode)

alert('B' > 'a'); // Output: false



* 
* This means 'a' is considered "greater" than 'Z'. This might seem counter-intuitive compared to standard alphabetical order, but it's consistent with Unicode.


---


## **Comparison of Different Types**

When you compare values of different types using comparison operators (like ==, >, &lt;, >=, &lt;=, !=), JavaScript typically performs **type conversion** to numbers.

**Examples:**

JavaScript

alert('2' > 1);  // Output: true. String '2' is converted to number 2. (2 > 1) is true.

alert('01' == 1); // Output: true. String '01' is converted to number 1. (1 == 1) is true.

For boolean values:



* true is converted to 1.
* false is converted to 0.

JavaScript

alert(true == 1);  // Output: true. true is converted to 1. (1 == 1) is true.

alert(false == 0); // Output: true. false is converted to 0. (0 == 0) is true.


### **A "Funny Consequence"**

Due to these type conversion rules, it's possible to have a situation where:



1. Two values are considered equal by ==.
2. But one of them is true as a boolean, and the other is false as a boolean.

JavaScript

let a = 0;

alert( Boolean(a) ); // Output: false (0 is a falsy value)

let b = "0";

alert( Boolean(b) ); // Output: true ("0" is a non-empty string, thus truthy)

alert(a == b); // Output: true!

**Explanation:**



* For the a == b comparison, JavaScript converts the string "0" to a number 0. So, it effectively compares 0 == 0, which is true.
* For Boolean(a), 0 is a "falsy" value, so it becomes false.
* For Boolean(b), "0" is a non-empty string, which is a "truthy" value, so it becomes true.

This highlights the different conversion rules for == (numeric conversion) versus Boolean() (falsy/truthy rules).


---


## **Strict Equality (===)**

The regular equality operator == has a significant "problem" (or, rather, a "feature" that can lead to unexpected behavior): it performs type coercion (automatic type conversion) before comparing values.

This can lead to results like:

JavaScript

alert(0 == false); // Output: true (0 is converted to false, or false to 0, depending on implementation detail)

alert('' == false); // Output: true (empty string converted to 0, false converted to 0)

alert('1' == 1);   // Output: true (string "1" converted to number 1)

To avoid these confusing type coercions and ensure a stricter comparison, JavaScript provides the **strict equality operator (===)**.



* The === operator checks for equality **without performing any type conversion**.
* If the operands are of different types, === immediately returns false. It does not attempt to convert them.

**Examples with Strict Equality:**

JavaScript

alert(0 === false); // Output: false (types are different: number vs boolean)

alert('' === false); // Output: false (types are different: string vs boolean)

alert('1' === 1);   // Output: false (types are different: string vs number)

There is also a **strict non-equality operator !==**, which is the opposite of ===.

JavaScript

alert(0 !== false); // Output: true (0 is not strictly equal to false)

alert('1' !== 1);   // Output: true ("1" is not strictly equal to 1)

**Recommendation:** In modern JavaScript development, it is generally considered a **best practice to use === (strict equality)** over == (loose equality) to prevent unexpected type coercion issues and make your code more predictable and robust. Use == only when you are absolutely certain that you want type coercion to occur.


---


## **Comparison with null and undefined**

Comparisons involving null and undefined can be particularly non-intuitive due to special rules.


### **For Strict Equality (===):**



* null and undefined are of different types.
* Therefore, for ===, they are considered different values.

JavaScript

alert(null === undefined); // Output: false (Different types)


### **For Loose Equality (==):**



* There's a **special rule**: null and undefined are considered "a sweet couple" – they **equal each other** but do not equal any other value (except themselves) when using ==.

JavaScript

alert(null == undefined); // Output: true (Special rule)

alert(null == 0);         // Output: false (null only equals undefined with ==)

alert(undefined == 0);    // Output: false (undefined only equals null with ==)

alert(null == '');        // Output: false


### **For Mathematical Comparisons (&lt;, >, &lt;=, >=):**



* When null or undefined are used in mathematical comparisons, they are converted to numbers:
    * null becomes 0.
    * undefined becomes NaN (Not a Number).

Let's look at the consequences of these rules:


#### **Strange Result: null vs 0**

JavaScript

alert(null > 0);  // (1) Output: false

alert(null == 0); // (2) Output: false

alert(null >= 0); // (3) Output: true

This sequence seems mathematically contradictory (null is not greater than 0, but it is greater than or equal to 0?).

The reason:



* For comparisons > and >= (like (1) and (3)), null is converted to a number 0.
    * So, null > 0 becomes 0 > 0, which is false.
    * And null >= 0 becomes 0 >= 0, which is true.
* However, for the loose equality == ((2)), null has the special rule: it only equals undefined and itself. It does *not* equal 0. So, null == 0 is false.

This demonstrates that == and mathematical comparisons (>, &lt;, etc.) apply different conversion rules.


#### **An Incomparable undefined**

The undefined value behaves even more consistently "falsy" or "NaN-like" in comparisons:

JavaScript

alert(undefined > 0);  // (1) Output: false

alert(undefined &lt; 0);  // (2) Output: false

alert(undefined == 0); // (3) Output: false

Why does undefined consistently return false here?



* For comparisons > and &lt; ((1) and (2)), undefined is converted to NaN. NaN has a unique property: it returns false for *all* comparisons (including itself, NaN == NaN is false!). So, NaN > 0 is false, and NaN &lt; 0 is false.
* For the loose equality == ((3)), undefined only equals null (and itself), as per its special rule. It does not equal 0. So, undefined == 0 is false.


### **How to Avoid Problems**

These quirks with null and undefined comparisons can be a source of tricky bugs. The best way to avoid them is to follow a simple rule:

**Treat any comparison involving undefined or null (except for strict equality ===) with extreme caution.**



* **Do not use comparison operators (>, &lt;, >=, &lt;=) with variables that might contain null or undefined,** unless you are absolutely sure of the specific type conversion behavior you want.
* If a variable could be null or undefined, it's often better to **check for these values separately** using strict equality or a type check before performing other comparisons.

JavaScript

let value = null; // or undefined

if (value === null || value === undefined) {

  // Handle null/undefined case specifically

  alert("Value is null or undefined");

} else if (value > 0) {

  // Proceed with other comparisons only if not null/undefined

  alert("Value is positive");

}


---


## **Summary**



* **Comparison operators** return a boolean value (true or false).
* **String comparison** is done letter-by-letter based on **Unicode order** (lexicographical comparison). Case matters.
* When **comparing values of different types** (with loose equality == or mathematical comparisons), JavaScript generally **converts them to numbers** (with special rules for null/undefined).
* The **strict equality operator (===)** checks for equality *without* type conversion. It's generally preferred to == to avoid unexpected behavior.
* **null and undefined**:
    * With ===, they are distinct (null === undefined is false).
    * With ==, they equal each other (null == undefined is true), but do not equal any other value.
    * In mathematical comparisons (>, &lt;, etc.), null becomes 0, while undefined becomes NaN. Since NaN fails all comparisons, undefined will always result in false for mathematical comparisons.
* **Best Practice**: Be very cautious with comparisons involving null or undefined (especially loose equality and mathematical comparisons). Prefer === for reliable checks, and handle null/undefined cases explicitly.


---


## **Tasks**


### **Comparisons**

What will be the result for these expressions?

JavaScript

5 > 4

"apple" > "pineapple"

"2" > "12"

undefined == null

undefined === null

null == "\n0\n"

null === +"\n0\n"
