# **JavaScript Key-Value Pairs & Object.entries**

## Introduction – Why Key-Value Pairs Matter

In JavaScript, almost everything in your code can be represented as **key-value pairs** — from storing user details to organizing product data in an online store.
Think of them like labels on containers:

* **Key** → the label (“name”, “price”)
* **Value** → what’s inside (“Alice”, `49.99`)

Once you understand how to work with them, you’ll be able to **store, retrieve, and transform data** with ease — and write cleaner, more powerful code.

---

## 1. Basics of Key-Value Pairs

A **key-value pair** links an identifier (the key) to a piece of data (the value).

### In Objects

```js
const person = {
  name: "John",
  age: 30,
  city: "New York"
};
```

Here:

* `"name"` → `"John"`
* `"age"` → `30`
* `"city"` → `"New York"`

Access values:

```js
console.log(person.name);     // "John"
console.log(person["age"]);   // 30
```

### In Arrays

Arrays use **numeric keys** (indexes):

```js
const fruits = ["apple", "banana", "cherry"];
console.log(fruits[0]); // "apple"
```

---

## 2. `Object.entries()` – Turning Objects into Arrays

`Object.entries()` takes an object and returns an array of `[key, value]` pairs.

Example:

```js
const person = {
  name: "Alice",
  age: 28,
  city: "London"
};

console.log(Object.entries(person));
// [
//   ["name", "Alice"],
//   ["age", 28],
//   ["city", "London"]
// ]
```

Why is this useful?
Once in array form, you can use loops or array methods to transform the data easily.

---

## 3. Looping Through Entries

**Using `for...of`:**

```js
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`);
}
// name: Alice
// age: 28
// city: London
```

**Using `.forEach()`:**

```js
Object.entries(person).forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});
```

---

## 4. Mapping & Transforming Data

Key-value pairs make it easy to reshape data.

### Mapping Objects

```js
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 35
};

const mappedPerson = {
  name: `${person.firstName} ${person.lastName}`,
  age: person.age
};

console.log(mappedPerson);
// { name: "John Doe", age: 35 }
```



---

## 5. Practical Use Cases

* **Form validation**

```js
const formData = { username: "john_doe", email: "john@example.com" };

if (!formData.hasOwnProperty("username")) {
  console.error("Username is required.");
}
```

* **Data normalization**

```js
const rawUser = { userName: "Jane_Doe", userEmail: "Jane@Example.com" };

const normalizedUser = {
  username: rawUser.userName.toLowerCase(),
  email: rawUser.userEmail.toLowerCase()
};
```

* **Custom dictionaries**

```js
const dictionary = {
  apple: "A fruit",
  dog: "A pet",
  book: "Something to read"
};

console.log(dictionary.apple); // "A fruit"
```

---

## 6. Pitfalls & How to Avoid Them

❌ **Accessing non-existent keys**

```js
console.log(person.gender); // undefined
```

✅ Check before accessing:

```js
if ("gender" in person) { ... }
```

❌ **Overwriting values by mistake**

```js
person.name = "Charlie"; // overwrites existing value
```

✅ Use immutable copies:

```js
const updatedPerson = { ...person, name: "Charlie" };
```

❌ **Inconsistent key types**

```js
const obj = { "2": "Alice", 2: "Bob" };
console.log(obj[2]); // "Bob"
```

✅ Keep key types consistent.

---

## Summary

* **Key-value pairs** are the backbone of data storage in JS.
* `Object.entries()` turns objects into iterable arrays of `[key, value]`.
* Great for **mapping, transforming, and validating** data.
* Watch out for **missing keys**, **accidental overwrites**, and **type mismatches**.


