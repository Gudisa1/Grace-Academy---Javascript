# Understanding the Event Object in JavaScript

When you interact with a web page, like clicking a button, typing in a text field, or submitting a form, **JavaScript generates an event**. But how do we know exactly what happened and where? This is where the **event object** comes in.

The **event object** is automatically passed to the event handler and contains all the useful information about that event. Let’s explore it step by step.

---

## 1. What is the Event Object?

Every time an event occurs in JavaScript, an **event object** is created. This object contains details like:

* Which element triggered the event
* What type of event it is (click, keypress, submit, etc.)
* Additional info like which key was pressed or mouse coordinates

You can access this object by passing a parameter to your event listener function:

```javascript
button.addEventListener('click', function(event) {
  console.log(event);
});
```

Here, `event` is the event object.

---

## 2. Important Properties of the Event Object

Let’s look at some key properties you’ll use most often.

### a) `target`

The **`target`** property refers to the element that **actually triggered the event**.

```html
<button id="myButton">Click Me!</button>

<script>
const button = document.getElementById('myButton');

button.addEventListener('click', (event) => {
  console.log('Target:', event.target); // Logs the button element
});
</script>
```

If you click the button, `event.target` points directly to the button.

---

### b) `currentTarget`

The **`currentTarget`** property refers to the element the **event listener is attached to**.

This can be different from `target` in nested elements:

```html
<div id="parent" style="padding:20px; border:1px solid black;">
  Parent Div
  <button id="child">Click Me</button>
</div>

<script>
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('click', (event) => {
  console.log('Target:', event.target);        // Actual clicked element
  console.log('Current Target:', event.currentTarget); // Element listener attached to
});
</script>
```

Click the button inside the div:

```
Target: button#child
Current Target: div#parent
```

---

### c) `keyCode` / `code`

When handling **keyboard events**, these properties tell you **which key was pressed**.

```html
<input type="text" id="myInput" placeholder="Type something...">

<script>
const input = document.getElementById('myInput');

input.addEventListener('keydown', (event) => {
  console.log('Key pressed:', event.key);   // e.g., 'a'
  console.log('Key code:', event.code);     // e.g., 'KeyA'
});
</script>
```

* `event.key` gives the character (like `'a'` or `'Enter'`)
* `event.code` gives the physical key on the keyboard (like `'KeyA'`)

---

## 3. `event.preventDefault()`

Some events, like **form submission or link clicks**, have default behaviors. You can **prevent them** using `preventDefault()`.

```html
<form id="myForm">
  <input type="text" placeholder="Type something">
  <button type="submit">Submit</button>
</form>

<script>
const form = document.getElementById('myForm');

form.addEventListener('submit', (event) => {
  event.preventDefault(); // Stops form from submitting
  alert('Form submission prevented!');
});
</script>
```

This is useful when you want to **validate data or handle submission with JavaScript** before letting the form submit.

---

## 4. `event.stopPropagation()`

Sometimes, you don’t want an event to bubble up to parent elements. That’s where **`stopPropagation()`** comes in.

```html
<div id="outer" style="padding:20px; border:1px solid red;">
  Outer Div
  <button id="inner">Click Me</button>
</div>

<script>
const outer = document.getElementById('outer');
const inner = document.getElementById('inner');

outer.addEventListener('click', () => {
  console.log('Outer Div clicked!');
});

inner.addEventListener('click', (event) => {
  console.log('Inner Button clicked!');
  event.stopPropagation(); // Prevent bubbling to outer div
});
</script>
```

Clicking the button now logs only:

```
Inner Button clicked!
```

Without `stopPropagation()`, both the inner button and outer div handlers would run.

---

## 5. Putting It All Together

Here’s a mini practical example using several event object features:

```html
<div id="parent" style="padding:20px; border:1px solid black;">
  Parent Div
  <button id="child">Click Me</button>
  <form id="myForm">
    <input type="text" placeholder="Type...">
    <button type="submit">Submit</button>
  </form>
</div>

<script>
const parent = document.getElementById('parent');
const child = document.getElementById('child');
const form = document.getElementById('myForm');
const input = form.querySelector('input');

parent.addEventListener('click', (event) => {
  console.log('Parent listener - currentTarget:', event.currentTarget);
});

child.addEventListener('click', (event) => {
  console.log('Child clicked - target:', event.target);
  event.stopPropagation();
});

input.addEventListener('keydown', (event) => {
  console.log(`Key pressed: ${event.key}, Code: ${event.code}`);
});

form.addEventListener('submit', (event) => {
  event.preventDefault();
  alert('Form submission prevented!');
});
</script>
```

This example shows:

* `target` vs `currentTarget`
* Keyboard event info
* Preventing form submission
* Stopping event propagation

---

## Conclusion

The **event object** is your gateway to understanding exactly what happens during user interactions. By learning its properties and methods like:

* `target`
* `currentTarget`
* `keyCode` / `code`
* `preventDefault()`
* `stopPropagation()`

…you gain **full control over events** in your web applications.

Start experimenting with these step by step, and you’ll soon feel confident handling even complex interactions!

---
